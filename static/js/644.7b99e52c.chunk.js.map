{"version":3,"file":"static/js/644.7b99e52c.chunk.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","sim/expressions/Expression.ts","sim/expressions/ExpressionCreator.ts","sim/expressions/expressionUtils.ts","sim/expressions/splitOperatorExpressions.ts","util/range.ts","sim/expressions/unaryOperatorExpressions.ts","sim/expressions/valueExpressions.ts","sim/parse.ts","sim/SimState.ts","../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/inherits.js","../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/@babel/runtime/helpers/esm/createSuper.js","../node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","sim/Simulation.ts","worker/worker.ts","util/Distribution.ts"],"sourcesContent":["export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","import SimState from '../SimState';\n\nexport type EvalFunc<T> = (s: SimState, ctx: Expression<T>) => number;\n\nexport default class Expression<T = unknown> {\n  typeName: string;\n  rawExpression: string;\n  subExpressions: Expression[];\n  evalFunc: EvalFunc<T>;\n  props: T;\n\n  constructor(typeName: string, expr: string, subExprs: Expression[], evalFunc: EvalFunc<T>, props: T) {\n    this.typeName = typeName;\n    this.rawExpression = expr;\n    this.subExpressions = subExprs;\n    this.evalFunc = evalFunc;\n    this.props = props;\n  }\n\n  eval(state: SimState): number {\n    return this.evalFunc(state, this);\n  }\n}\n","import Expression, { EvalFunc } from './Expression';\n\nexport type ParseFunc<T> = (match: RegExpExecArray, subExprs: Expression[]) => T;\n\ninterface ExpressionParams<T> {\n  typeName: string;\n  regex: RegExp;\n  numOperands?: number;\n  parseFunc: ParseFunc<T>;\n  evalFunc: EvalFunc<T>;\n  sample: string;\n  description: string;\n}\n\nexport default class ExpressionCreator<T> {\n  typeName: string;\n  regex: RegExp;\n  globalRegex: RegExp;\n  parseFunc: ParseFunc<T>;\n  evalFunc: EvalFunc<T>;\n  numOperands: number; \n  sample: string;\n  description: string;\n\n  constructor(params: ExpressionParams<T>) {\n    this.typeName = params.typeName;\n    this.regex = params.regex;\n    const gFlags = params.regex.flags ? `${params.regex.flags}g` : 'g';\n    this.globalRegex = new RegExp(params.regex.source, gFlags);\n    this.parseFunc = params.parseFunc\n    this.evalFunc = params.evalFunc;\n    this.numOperands = params.numOperands || 0; \n\n    this.sample = params.sample;\n    this.description = params.description;\n  }\n\n  create(expr: string, subExprs: Expression[], match: RegExpExecArray) {\n    if ((this.numOperands && subExprs.length !== this.numOperands)) {\n      throw Error(`Invalid syntax in \"${expr}\": ${this.typeName} expected ${this.numOperands} operands but got ${subExprs.length}`);\n    }\n    const props: T = this.parseFunc(match, subExprs);\n    return new Expression(this.typeName, expr, subExprs, this.evalFunc, props);\n  }\n}\n","const NoPF = () => ({});\n\nlet randomFunction = Math.random;\nconst sum = (values: number[]) => values.reduce((prev, cur) => prev + cur, 0);\nconst roll = (die: number) => Math.floor(randomFunction() * die) + 1;\n\nexport const exportedForTesting = {\n  setRandomFunction: (func: () => number) => randomFunction = func,\n};\n\nconst expressionUtils = { NoPF, sum, roll };\n\nexport default expressionUtils;\n","import { range } from 'util/range';\nimport ExpressionCreator, { ParseFunc } from './ExpressionCreator';\nimport Expression, { EvalFunc } from './Expression';\nimport expressionUtils from './expressionUtils';\n\nconst { NoPF, sum, roll } = expressionUtils;\n\nfunction splitExpr<T>(\n  typeName: string,\n  sample: string,\n  regex: RegExp,\n  parseFunc: ParseFunc<T>,\n  evalFunc: EvalFunc<T>,\n  description: string,\n) {\n  return new ExpressionCreator({\n    typeName,\n    regex,\n    numOperands: 2,\n    parseFunc,\n    evalFunc,\n    description,\n    sample\n  });\n}\n\nconst checkType = (expr: Expression, type_names: string[]) => {\n  if (!type_names.includes(expr.typeName)) {\n    throw Error(`Type of \"${expr.rawExpression}\" was expected to be one of \"${type_names}\", but was \"${expr.typeName}\"`)\n  }\n  return expr.typeName;\n}\n\nconst parseVantage = (vantage: string, num?: string) => {\n  if (vantage === 'adv') {\n    return Number(num || 2)\n  } else if (vantage === 'dis') {\n    return -Number(num || 2)\n  }\n  return 0;\n};\n\nexport const SplitExpressions = [\n  splitExpr('Discard', ';', /;/, NoPF,\n    (s, ctx) => (void ctx.subExpressions[0].eval(s)) || ctx.subExpressions[1].eval(s),\n    `The result of the left operand is discarded (though is still evaluated, so \\\nvariables and functions will be assigned); output is the result of the \\\nright operand. Can be useful after assignment when the assigned value should \\\nnot be immediately added.`\n  ),\n  splitExpr('Assign', ':=', /:=/,\n    (m, exprs) => ({ storedType: checkType(exprs[0], ['Variable', 'Function']) }),\n    (s, ctx) => {\n      if (ctx.props.storedType === 'Function') {\n        const funcName = (ctx.subExpressions[0].props as { funcName: string })?.funcName;\n        s.funcReg.set(funcName, ctx.subExpressions[1]);\n      } else if (ctx.props.storedType === 'Variable') {\n        const varName = (ctx.subExpressions[0].props as { varName: string })?.varName;\n        const value = ctx.subExpressions[1].eval(s);\n        s.varReg.set(varName, value);\n      }\n      return 0;\n    },\n    `Assign value to variable or sub expression to function. Output is 0.\n\nFor example:\n  $a := 1d6\nIn the above, the outcome of the 1d6 roll will be assigned to $a for later use. \\\nThis can be useful in cases where you need to know the outcome of an earlier \\\nattack, such as whether you've already used your sneak attack for the turn:\n  ($a := (3+PB =atk> 1D6+3 + 1D6)) + (3+PB =atk> 1D6 + ($a<=0 => 1D6))\n\nCan also assign a sub expression as a function:\n  @a := 3+PB =atk> 1D6+3\nIn the above, the attack sub expression is assigned to $a for later use. Each \\\ntime it is used later, it will be re-evaluated (dice will be rolled again):\n  (@a := 1D6+3); (3+PB =atk> @a) + (5+PB =atk> @a)\n\nThese can be combined to useful effect; for example, effects that can only\nhappen once per turn, but have multiple opportunities to happen, like sneak \\\nattack:\n  @sa := !$sd => ($sd=1D6); (3+PB =atk> 1D6+3 + @sa) + (3+PB =atk> 1D6 + @sa)\nThe above defines a function \"@sa\" (sneak attack) that will roll 1D6, and assign \\\nthe result to \"$sd\" (sneak damage); but only if \"$sd\" is a not (\"!\") zero (i.e. \\\nhas already been rolled). The \";\" separates it from the rest of the expression. \\\nThen \"@sd\" can be inserted anywhere the sneak attack could occur (on any attack \\\nhit). Note that this method will mean that the sneak attack always occurs on \\\nthe first attack that hits.`,\n  ),\n  splitExpr('Assign (and Evaluate)', '=', /(?<![=<>!:&|])=(?![=>a-zA-Z])/,\n    (m, exprs) => ({ storedType: checkType(exprs[0], ['Variable', 'Function']) }),\n    (s, ctx) => {\n      if (ctx.props.storedType === 'Function') {\n        const funcName = (ctx.subExpressions[0].props as { funcName: string })?.funcName;\n        s.funcReg.set(funcName, ctx.subExpressions[1]);\n        return s.funcReg.get(funcName)?.eval(s) || 0;\n      } else if (ctx.props.storedType === 'Variable') {\n        const varName = (ctx.subExpressions[0].props as { varName: string })?.varName;\n        const value = ctx.subExpressions[1].eval(s);\n        s.varReg.set(varName, value);\n        return value;\n      }\n      return 0;\n    },\n    `Assign value to variable or sub expression to function. Output is the \\\nresult of evaluating the assigned expression. This is the same as \":=\", except \\\nfor the output. NOTE this means that any assigned function will be evaluated\\\nimmediately, and any variables changed as part of the function will be changed \\\nwhen it is immediately evaluated!`,\n  ),\n//   splitExpr('Assign If Not Already Zero', '|=', /\\|=/,\n//     (m, exprs) => ({ storedType: checkType(exprs[0], ['Variable']) }),\n//     (s, ctx) => {\n//       if (ctx.props.storedType === 'Variable') {\n//         const varName = (ctx.subExpressions[0].props as { varName: string })?.varName;\n//         const oldValue = s.varReg.get(varName);\n//         if (!oldValue) {\n//           const value = ctx.subExpressions[1].eval(s);\n//           s.varReg.set(varName, value);\n//           return value;\n//         }\n//         return oldValue;\n//       }\n//       return 0;\n//     },\n//     `Assigns to the variable if it is not already set or is set to zero. The \\\n//     following expressions are equivalent:\n//       $a |= 2\n//       $a = $a || 2`,\n//   ),\n//   splitExpr('Assign If Already Non-Zero', '&=', /&=/,\n//     (m, exprs) => ({ storedType: checkType(exprs[0], ['Variable']) }),\n//     (s, ctx) => {\n//       if (ctx.props.storedType === 'Variable') {\n//         const varName = (ctx.subExpressions[0].props as { varName: string })?.varName;\n//         const oldValue = s.varReg.get(varName);\n//         if (oldValue) {\n//           const value = ctx.subExpressions[1].eval(s);\n//           s.varReg.set(varName, value);\n//           return value;\n//         }\n//         return oldValue || 0;\n//       }\n//       return 0;\n//     },\n//     `Assigns to the variable if it is already set to a non-zero value. The \\\n// following expressions are equivalent:\n//   $a &= 2\n//   $a = $a && 2`,\n//   ),\n  splitExpr('Check', '=>', /=>/, NoPF, (s, ctx) => (ctx.subExpressions[0].eval(s) ? ctx.subExpressions[1].eval(s) : 0),\n    `If left operand is non-zero, then output the right operand, otherwise \\\noutput 0. For example:\n  (1d20 <= 11) => 1d8`\n  ),\n  splitExpr('Attack', '=atk>', /=atk(?::(\\d+))?(?::(adv|dis)(\\d+)?)?>/,\n    (m) => ({ critmin: Number(m[1] || 20), vantage: parseVantage(m[2], m[3]) }),\n    (state, { props, subExpressions }) => {\n      let droll = roll(20);\n      if (props.vantage > 1 || props.vantage < -1) {\n        const rolls = range(Math.abs(props.vantage) - 1).map(() => roll(20));\n        const reducer = props.vantage > 0 ? Math.max : Math.min;\n        droll = reducer(droll, ...rolls);\n      }\n      const critMiss = droll === 1;\n      const critHit = droll >= props.critmin;\n      if (!critMiss && (critHit || (subExpressions[0].eval(state) + droll >= state.ac))) {\n        state.pushCrit(critHit);\n        const result = subExpressions[1].eval(state);\n        state.popCrit();\n        return result;\n      }\n      return 0;\n    },\n    `Make an attack. The left operand will be added to the d20 roll, and if \\\nthe result meets the AC then the output is the right operand. For example:\n  3+PB =atk> 1D6+3\nThe above is mostly equivalent to:\n  (3+PB + 1d20 >= AC) => 1D6+3\nHowever, the =atk> operator also accounts for crits. If the d20 rolled for the \\\nattack is a 1, then the attack will miss regardless of modifiers and AC. If the \\\nd20 rolled for the attack is a 20, then the critical hit flag is set (the \\\nnumber of dice rolled in the 1D6 damage roll will then be doubled; note that \\\nthe doubling of dice only applies when the uppercase D is used; using a \\\nlowercase d will not double dice).\n\nCan also specify that the attack be made with advantage or disadvantage:\n  3+PB =atk:adv> 1D6+3\n  3+PB =atk:dis> 1D6+3\nOr even super advantage or disadvantage:\n  3+PB =atk:adv3> 1D6+3\n  3+PB =atk:dis3> 1D6+3\n\nCan also specify the minimum critical hit threshold, for example if you can \\\ncrit on a 19:\n  3+PB =atk:19> 1D6+3\n\nNote that if you specify both adv/dis and crit threshold, the crit threshold \\\nshould come first:\n3+PB =atk:19:dis> 1D6+3`,\n  ),\n  splitExpr('Save', '=sav>', /=sav:(\\d+)(?::(adv|dis))?>/,\n    (m) => ({ successmod: (Number(m[1]) / 100.0) ?? 0.5, vantage: m[2] }),\n    (state, ctx) => {\n      let droll = roll(20);\n      if (ctx.props.vantage === 'adv') {\n        droll = Math.max(droll, roll(20));\n      } else if (ctx.props.vantage === 'dis') {\n        droll = Math.min(droll, roll(20));\n      }\n\n      const dmg = ctx.subExpressions[1].eval(state)\n      if (droll + state.sm >= ctx.subExpressions[0].eval(state)) {\n        return Math.floor(dmg * ctx.props.successmod);\n      }\n      return dmg;\n    },\n    `Have the target make a saving throw. The left operand is the difficulty \\\nclass (DC) of the save; if the target save (1d20 + SM) does not meet the DC, \\\nthen the output will be the right operand. Otherwise, if the target save does \\\nmeet the DC, then the output will be half the right operand. For example:\n  8+3+PB =sav> 3d8\nThe above is equivalent to:\n  ($s := 1d20 + SM) + ($s < 8+3+PB => 3d8) + ($s >= 8+3+PB => 3d8/2)\n\nCan also specify that the save be made with advantage or disadvantage:\n  8+3+PB =sav:adv> 3d8\n  8+3+PB =sav:dis> 3d8\n\nCan also specify the output modifier for save success, for example if suceeding \\\non the save results in no damage being taken:\n  8+3+PB =sav:0> 3d8\nNote the the success modifier is specified as a positive integer percentage, so \\\na value of 25 would mean that the damage is quartered.\n\nNote that if you specify both adv/dis and success modifier, the success modifier \\\nshould come first:\n  8+3+PB =sav:0:adv> 3d8`,\n  ),\n  splitExpr('Or', '||', /\\|\\|/, NoPF,\n    (s, ctx) => ctx.subExpressions[0].eval(s) || ctx.subExpressions[1].eval(s),\n    'Outputs the second operand if the first is 0, otherwise outputs the first operand.',\n  ),\n  splitExpr('And', '&&', /&&/, NoPF,\n    (s, ctx) => ctx.subExpressions[0].eval(s) && ctx.subExpressions[1].eval(s),\n    'Outputs the second operand if the first is non-zero, otherwise outputs 0',\n  ),\n  splitExpr('Greater Than Or Equal To', '>=', />=/, NoPF,\n    (s, ctx) => Number(ctx.subExpressions[0].eval(s) >= ctx.subExpressions[1].eval(s)),\n    'Outputs 1 if the left operand is greater than or equal to the right operand, otherwise 0.',\n  ),\n  splitExpr('Greater Than', '>', /(?<!=)>(?!=)/, NoPF,\n    (s, ctx) => Number(ctx.subExpressions[0].eval(s) > ctx.subExpressions[1].eval(s)),\n    'Outputs 1 if the left operand is greater than the right operand, otherwise 0.',\n  ),\n  splitExpr('Less Than Or Equal To', '<=', /<=/, NoPF,\n    (s, ctx) => Number(ctx.subExpressions[0].eval(s) <= ctx.subExpressions[1].eval(s)),\n    'Outputs 1 if the left operand is less than or equal to the right operand, otherwise 0.',\n  ),\n  splitExpr('Less Than', '<', /(?<!=)<(?!=)/, NoPF,\n    (s, ctx) => Number(ctx.subExpressions[0].eval(s) < ctx.subExpressions[1].eval(s)),\n    'Outputs 1 if the left operand is less than the right operand, otherwise 0.',\n  ),\n  splitExpr('Not Equal To', '!=', /!=(?!>)/, NoPF,\n    (s, ctx) => Number(ctx.subExpressions[0].eval(s) !== ctx.subExpressions[1].eval(s)),\n    'Outputs 1 if the left operand is not equal to the right operand, otherwise 0.',\n  ),\n  splitExpr('Equal To', '==', /==(?!>)/, NoPF,\n    (s, ctx) => Number(ctx.subExpressions[0].eval(s) === ctx.subExpressions[1].eval(s)),\n    'Outputs 1 if the left operand is equal to the right operand, otherwise 0.',\n  ),\n  splitExpr('Add', '+', /\\+/, NoPF,\n    (s, ctx) => sum(ctx.subExpressions.map((e) => e.eval(s))),\n    'Outputs the sum of the left operand and right operand',\n  ),\n  splitExpr('Subtract', '-', /(?<![-+*/=><|&])-(?!>)/, NoPF,\n    (s, ctx) => ctx.subExpressions[0].eval(s) - sum(ctx.subExpressions.slice(1).map((e) => e.eval(s))),\n    'Outputs the result of subtracting the right operand from the left operand.',\n  ),\n  splitExpr('Multiply', '*', /\\*/, NoPF,\n    (s, ctx) => ctx.subExpressions.reduce((a, e) => a * e.eval(s), 1),\n    'Outputs the result of multiplying the left operand by the right operand.',\n  ),\n  splitExpr('Divide', '/', /\\//, NoPF,\n    (s, ctx) => Math.floor(ctx.subExpressions[0].eval(s) / ctx.subExpressions[1].eval(s)),\n    `Outputs the result of dividing the left operand by the right oeprand. \\\nDecimal results are rounded down the nearest whole integer.`,\n  ),\n  splitExpr('Repeat', '#', /#/, NoPF,\n    (s, ctx) => sum([...new Array(Number(ctx.subExpressions[0].eval(s)))].map(() => ctx.subExpressions[1].eval(s))),\n    `Outputs the sum of repeating evaluation of the right operand a number of \\\ntimes equal to the left operand.`\n  ),\n  // TODO: Remove this at some point\n  splitExpr('Reroll (If Less Than Or Equal To)', '@rrlte:', /@rrlte:/,\n    (): {} => { throw new Error('@rrlte: has been removed; use the 2d6rrle2 syntax instead') },\n    () => { throw new Error('@rrlte: has been removed; use the 2d6rrle2 syntax instead') },\n    '',\n  ),\n];\n","\nexport function range(stop: number): number[];\nexport function range(start: number, stop: number): number[];\nexport function range(start: number, stop: number, step: number): number[];\nexport function range(start: number, stop?: number, step?: number): number[] {\n  if (stop === undefined) {\n      // one param defined\n      stop = start;\n      start = 0;\n  }\n\n  if (step === undefined) {\n      step = 1;\n  }\n\n  if ((step > 0 && start >= stop) || (step < 0 && start <= stop)) {\n      return [];\n  }\n\n  var result = [];\n  for (var i = start; step > 0 ? i < stop : i > stop; i += step) {\n      result.push(i);\n  }\n\n  return result;\n};\n","import ExpressionCreator, { ParseFunc } from './ExpressionCreator';\nimport { EvalFunc } from './Expression';\nimport expressionUtils from './expressionUtils';\n\nconst { NoPF } = expressionUtils;\n\nfunction unaryExpr<T>(\n  typeName: string,\n  sample: string,\n  regex: RegExp,\n  parseFunc: ParseFunc<T>,\n  evalFunc: EvalFunc<T>,\n  description: string,\n) {\n  return new ExpressionCreator({\n    typeName,\n    regex,\n    numOperands: 1,\n    parseFunc,\n    evalFunc,\n    description,\n    sample\n  });\n}\n\nexport const UnaryExpressions = [\n  unaryExpr('Not', '!', /^!/, NoPF,\n    (s, ctx) => (ctx.subExpressions[0].eval(s) ? 0 : 1),\n    'Outputs 0 if the right operand is non-zero, otherwise outputs 1.',\n  ),\n  unaryExpr('Negative', '-', /^-/, NoPF,\n    (s, ctx) => (ctx.subExpressions[0].eval(s) * -1),\n    'Flips the sign of the right operand (multiply by -1).',\n  ),\n];\n","import ExpressionCreator, { ParseFunc } from './ExpressionCreator';\nimport { EvalFunc } from './Expression';\nimport expressionUtils from './expressionUtils';\n\nconst { NoPF, sum, roll } = expressionUtils;\n\nfunction valueExpr<T>(\n  typeName: string,\n  sample: string,\n  regex: RegExp,\n  parseFunc: ParseFunc<T>,\n  evalFunc: EvalFunc<T>,\n  description: string,\n) {\n  return new ExpressionCreator({\n    typeName,\n    regex,\n    parseFunc,\n    evalFunc,\n    description,\n    sample\n  });\n}\n\ntype RollOp = (rolls: number[], param: number, dieSize: number) => number[] | void;\nconst rollOperations: Record<string, RollOp> = {\n  kh: (rolls, param) => rolls.sort((a, b) => (b - a)).slice(0, param),\n  kl: (rolls, param) => rolls.sort((a, b) => (a - b)).slice(0, param),\n  rrle: (rolls, param, ds) => rolls.forEach((v, i, a) => { if (v <= param) a[i] = roll(ds); }),\n  rrlt: (rolls, param, ds) => rolls.forEach((v, i, a) => { if (v < param) a[i] = roll(ds); }),\n  rrge: (rolls, param, ds) => rolls.forEach((v, i, a) => { if (v >= param) a[i] = roll(ds); }),\n  rrgt: (rolls, param, ds) => rolls.forEach((v, i, a) => { if (v > param) a[i] = roll(ds); }),\n  rreq: (rolls, param, ds) => rolls.forEach((v, i, a) => { if (v === param) a[i] = roll(ds); }),\n};\nconst rollOpRegex = Object.keys(rollOperations).join('|');\n\nexport const ValueExpressions = [\n  valueExpr('Number', 'X', /^\\d+$/, (m) => ({ value: Number(m[0]) }), (s, { props }) => props.value,\n  'Where X is any positive integer. Outputs the value of the integer.',\n  ),\n  valueExpr('Roll Dice', 'XdY', new RegExp(`^(\\\\d*)([dD])(\\\\d+)((?:(?:${rollOpRegex})\\\\d+)*)$`),\n    (m) => {\n      return ({\n        crittable: m[2] === 'D',\n        dieSize: Number(m[3]),\n        numDice: Number(m[1] || 1),\n        operations: [...m[4].matchAll(/([a-zA-Z]+)(\\d+)/g)].map((om) => ({\n          operation: om[1],\n          param: Number(om[2]),\n        })),\n      });\n    },\n    (s, { props }) => {\n      const { crittable, dieSize, numDice, operations } = props;\n      let rolls: number[] = [];\n      const numWithCrit = (crittable && s.crit()) ? 2 * numDice : numDice;\n      for (let i = 0; i < numWithCrit; i += 1) {\n        rolls.push(roll(dieSize));\n      }\n      operations.forEach(({ operation, param }) => {\n        rolls = rollOperations[operation](rolls, param, dieSize) || rolls;\n      });\n      return sum(rolls);\n    },\n    `Where X and Y are any positive integers. Outputs the sum of rolls with a \\\ndice of size Y rolled X number of times. For example:\n  3d8\nIn the above, an 8 sided dice will be rolled 3 times, and the output will be \\\nthe sum of the results.\n\nCritical hits can be accounted for with an uppercase D to double the number of \\\ndice rolled on a critical hit:\n  3D8\nIn the above, if the critical hit flag is set  (in the right operand of an \\\nAttack where the attack roll was >= to the critical threshold), then an 8 sided \\\ndice will be rolled 6 times.\n\nCan also append additional modifier operations after the above basic rolls, \\\nsuch as \"keep highest\":\n  3d8kh2\nThe above rolls 3 d8s, and keeps the two highest rolls. To simulate the \"Great \\\nWeapon Fighting Style\" you could instead use rrle:\n  2D6rrle2\nWhich rolls 2 d6s (or 4 on a crit), and rerolls any 1s and 2s. Any number of \\\nthese operations can be appended, such as:\n  4d6kl2rrle2kh1\nWhich rolls 4 d6s, then keeps the lowest 2, then rerolls any of the remaining 2 \\\nthat are 2 or less, then keeps the highest 1 of those remaining 2.\n\nThe available modifier operations (where X is any positive integer) are:\n  khX: Keep the highest X dice\n  klX: Keep the lowest X dice\n  rrleX: Reroll (only once) any dice that are less than or equal to X\n  rrltX: Reroll (only once) any dice that are less than X\n  rrgeX: Reroll (only once) any dice that are greater than or equal to X\n  rrgtX: Reroll (only once) any dice that are greater than X\n  rreqX: Reroll (only once) any dice that are equal to X\n`\n  ),\n  valueExpr('Armor Class', 'AC', /^AC$/, NoPF, (s, ctx) => s.ac,\n    'Outputs the armor class of the target the simulation is being run against.'\n  ),\n  valueExpr('Save Modifier', 'SM', /^SM$/, NoPF, (s, ctx) => s.ac,\n    'Outputs the save modifier of the target the simulation is being run against.'\n  ),\n  valueExpr('Proficiency Bonus', 'PB', /^PB$/, NoPF, (s, ctx) => s.pb,\n    'Outputs the proficiency bonus for the level of the character build.'\n  ),\n  valueExpr('Level', 'LV', /^LV$/, NoPF, (s, ctx) => s.level,\n    'Outputs the level of the character build.'\n  ),\n  valueExpr('Critical Multiplier', 'CM', /^CM$/, NoPF, (s, ctx) => Number(s.crit()) * 1 + 1,\n    `Outputs 2 if critical flag is set (in the right operand of an Attack where \\\n  the attack roll was >= to the critical threshold), otherwise 1.`\n  ),\n  valueExpr('Critical Binary', 'CB', /^CB$/, NoPF, (s, ctx) => Number(s.crit()) * 1,\n    `Outputs 1 if critical flag is set (in the right operand of an Attack where \\\nthe attack roll was >= to the critical threshold), otherwise 0.`\n  ),\n  valueExpr('Variable', '$X', /^\\$([a-zA-Z]+)$/,\n    (m) => ({ varName: m[1] }),\n    (s, ctx) => s.varReg.get(ctx.props.varName) || 0,\n    `Where X is a string of alphanumeric characters. A variable that can be \\\nstored and retrieved. Outputs the value of the variable, which starts as 0. \\\nFor example:\n  $a := 1d6\nIn the above, the outcome of the 1d6 roll will be assigned to $a for later use. \\\nThis can be useful in cases where you need to know the outcome of an earlier \\\nattack, such as whether you've already used your sneak attack for the turn:\n  ($a := (3+PB =atk> 1D6+3 + 1D6)) + (3+PB =atk> 1D6 + ($a<=0 => 1D6)) + $a`,\n  ),\n  valueExpr('Function', '@X', /^@([a-zA-Z]+)$/,\n    (m) => ({ funcName: m[1] }),\n    (s, ctx) => s.funcReg.get(ctx.props.funcName)?.eval(s) || 0,\n    `Where X is a string of alphanumeric characters. A function that can be \\\nassigned a sub expression and then later evaluated. \\\nOutputs the result of evaluating the sub expression (any dice rolls will be \\\nrerolled each time), or 0 if an expression has not yet been assigned. For \\\nexample:\n  @a := 3+PB =atk> 1D6+3\nIn the above, the attack sub expression is assigned to $a for later use. Each \\\ntime it is used later, it will be re-evaluated (dice will be rolled again). \\\nThis can be useful in cases where you want to evaluate the same thing multiple \\\ntimes, like sneak attack after each attack:\n  (@sa := $sd<=0 => ($sd:=1D6)+$sd) + (3+PB =atk> 1D6+3 + @sa) + (3+PB =atk> 1D6 + @s) + $sd`,\n  ),\n];\n","import parseRanges from 'util/parseRanges';\nimport Expression from './expressions/Expression';\nimport ExpressionCreator from './expressions/ExpressionCreator';\nimport { SplitExpressions } from './expressions/splitOperatorExpressions';\nimport { UnaryExpressions } from './expressions/unaryOperatorExpressions';\nimport { ValueExpressions } from './expressions/valueExpressions';\nimport SimState from './SimState';\nimport Simulation from './Simulation';\n\nconst operatorExpressions = [...SplitExpressions, ...UnaryExpressions];\n\nfunction matchAt(matches: RegExpMatchArray[], index: number): RegExpExecArray | null {\n  for (let i = 0; i < matches.length; i++) {\n    if (matches[i].index === index) {\n      return matches[i] as RegExpExecArray;\n    }\n  }\n  return null;\n}\n\nfunction appendChunk(result: string[], chunk: string, resets: number) {\n  if (resets === 1 && chunk.startsWith('(') && chunk.endsWith(')')) {\n    chunk = chunk.substring(1, chunk.length - 1);\n  }\n  result.push(chunk);\n}\n\nfunction splitExpr(\n  expr: string, operator: ExpressionCreator<any>,\n): [string[], RegExpExecArray | null, number] {\n  const matches = [...expr.matchAll(operator.globalRegex)];\n  if (!matches.length) {\n    return [[], null, 0];\n  }\n\n  const result: string[] = [];\n  let braces = 0;\n  let currentChunk = '';\n  let chunkParensResets = 0;\n  let opMatch: RegExpExecArray | null = null;\n  let i = 0;\n  while (i < expr.length) {\n    const curChar = expr[i];\n    if (curChar === '(') {\n      braces += 1;\n    } else if (curChar === ')') {\n      braces -= 1;\n      if (braces === 0) {\n        chunkParensResets += 1;\n      }\n    }\n    if (braces === 0 && !opMatch && (operator.numOperands !== 2 || i > 0)) {\n      opMatch = matchAt(matches, i);\n      if (opMatch) {\n        appendChunk(result, currentChunk, chunkParensResets);\n        currentChunk = '';\n        chunkParensResets = 0;\n        i += opMatch[0].length;\n        continue;\n      }\n    }\n    currentChunk += curChar;\n    i += 1;\n  }\n  if (braces !== 0) {\n    throw Error(`Unbalanced parentheses in expression \"${expr}\"`);\n  }\n  appendChunk(result, currentChunk, chunkParensResets);\n  return [result.filter(Boolean), opMatch, chunkParensResets];\n}\n\nexport function parseSimExpr(rawExpr: string): Expression {\n  for (let exprCreator of operatorExpressions) {\n    const [parts, opMatch, parensGroups] = splitExpr(rawExpr, exprCreator)\n    if (parts.length === 1 && parensGroups === 1 && rawExpr.startsWith('(') && rawExpr.endsWith(')')) {\n      return parseSimExpr(parts[0]);\n    }\n    if (opMatch && parts.length === exprCreator.numOperands) {\n      return exprCreator.create(rawExpr, parts.map(parseSimExpr), opMatch) as Expression;\n    }\n  }\n\n  for (let exprCreator of ValueExpressions) {\n    const match = exprCreator.regex.exec(rawExpr);\n    if (match) {\n      return exprCreator.create(rawExpr, [], match) as Expression;\n    }\n  }\n\n  throw Error(`Invalid expression: \"${rawExpr}\"`)\n}\n\nexport function parseSimDef(simDef: string): Simulation[] {\n  const [nameLevel, expr] = simDef.split(/:(.*)/);\n  if (!expr) {\n    throw new Error(`Simulation definition \"${simDef}\" is not correctly formatted.`)\n  }\n  let levels = [0];\n  let name = nameLevel;\n  if (nameLevel.includes('@')) {\n    const [namePart, levelsPart] = name.split('@');\n    name = namePart;\n    levels = parseRanges([levelsPart]);\n  }\n  let expression: Expression<unknown>;\n  let error: string | undefined;\n  const rawExpr = expr.replace(/ /g, '');\n  try {\n    expression = parseSimExpr(rawExpr);\n  } catch (e) {\n    expression = parseSimExpr('0');\n    error = String(e);\n  }\n  return levels.map((level) => {\n    const sim = new Simulation(name, level, simDef, rawExpr, expression);\n    sim.error = error;\n    return sim;\n  });\n}\n\nexport function tryParseTestSimDef(simDef: string): Simulation[] {\n  const sims = parseSimDef(simDef);\n  sims.forEach((sim) => {\n    if (!sim.error) {\n      try {\n        // Perform a test run, to make sure it's all good!\n        sim.run(new SimState({ ac: 10, pb: 2, level: 1, sm: 0 }));\n      } catch (e) {\n        sim.error = String(e);\n      }\n    }\n  });\n  return sims;\n}\n\nexport function parseTestSimDef(simDef: string): Simulation[] {\n  const sims = tryParseTestSimDef(simDef);\n  const firstError = sims.find((s) => s.error)?.error;\n  if (firstError) {\n    throw new Error(firstError);\n  }\n  return sims;\n}\n","import Expression from './expressions/Expression';\nimport SimParams from './SimParams';\n\nclass SimState implements SimParams {\n  // Static state\n  readonly ac: number;\n  readonly level: number;\n  readonly pb: number;\n  readonly sm: number;\n\n  // Dynamic state\n  readonly critStack: boolean[];\n  readonly funcReg: Map<string, Expression>;\n  readonly varReg: Map<string, number>;\n\n  constructor(config: SimParams) {\n    this.ac = config.ac;\n    this.sm = config.sm;\n    this.pb = config.pb;\n    this.level = config.level;\n\n    this.varReg = new Map();\n    this.funcReg = new Map();\n    this.critStack = [];\n  }\n\n  crit() {\n    return !!this.critStack[this.critStack.length - 1];\n  }\n\n  popCrit() {\n    this.critStack.pop();\n  }\n\n  pushCrit(newCrit: boolean) {\n    this.critStack.push(newCrit);\n  }\n\n  reset() {\n    this.critStack.length = 0;\n    this.funcReg.clear();\n    this.varReg.clear();\n  }\n}\n\nexport default SimState;\n","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","import _typeof from \"./typeof.js\";\nimport assertThisInitialized from \"./assertThisInitialized.js\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return assertThisInitialized(self);\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nimport possibleConstructorReturn from \"./possibleConstructorReturn.js\";\nexport default function _createSuper(Derived) {\n  var hasNativeReflectConstruct = isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}","export default function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","import Expression from './expressions/Expression';\nimport SimState from './SimState';\n\nexport class BaseSimulation {\n  rawExpression: string;\n  rootExpression: Expression;\n\n  constructor(rawExpr: string, rootExpr: Expression) {\n    this.rawExpression = rawExpr\n    this.rootExpression = rootExpr\n  }\n\n  run(initialState: SimState) {\n    return this.rootExpression.eval(initialState)\n  }\n}\n\nexport default class Simulation extends BaseSimulation {\n  name: string;\n  level: number;\n  simDefinition: string;\n  error?: string;\n\n  constructor(name: string, level: number, simDef: string, rawExpr: string, rootExpr: Expression) {\n    super(rawExpr, rootExpr);\n    this.name = name;\n    this.level = level;\n    this.simDefinition = simDef;\n    this.error = undefined;\n  }\n  \n  id() {\n    return `${this.name}@${this.level}`;\n  }\n\n  isValid() {\n    return !this.error;\n  }\n}\n","import { parseSimExpr } from 'sim/parse';\nimport SimParams from 'sim/SimParams';\nimport SimState from 'sim/SimState';\nimport { BaseSimulation } from 'sim/Simulation';\nimport { MutableDistribution } from 'util/Distribution';\nimport { ToWorkerMessages } from './Messages';\n\n// Each worker will be effectively run in a separate interpreter, so global\n// state isn't actually very global; each worker will have their own copy of\n// the below state\nlet simulation: BaseSimulation | undefined;\nlet simParams: SimParams | undefined;\n\nonmessage = function(event: MessageEvent<ToWorkerMessages>) {\n  const { data } = event;\n  if (data.command === 'configure') {\n    const { expression, config } = data;\n    simulation = new BaseSimulation(expression, parseSimExpr(expression));\n    simParams = config;\n  } else if (data.command === 'run') {\n    const { iterations } = data;\n    const distribution = runSims(iterations);\n    this.postMessage({ command: 'complete', distribution });\n  }\n}\n\nfunction runSims(iterations: number) {\n  if (!simulation || !simParams) throw new Error('Worker is not configured!');\n  const results = new MutableDistribution();\n  const state = new SimState(simParams);\n  for (let i = 0; i < iterations; i++) {\n    state.reset();\n    results.increment(simulation.run(state));\n  }\n  return results.toImmutable();\n}\n\nexport {}\n","class Distribution {\n  protected map: Map<number, number>;\n  protected sumTotal: number;\n\n  constructor(entries?: [number, number][]) {\n    this.map = new Map(entries);\n    this.sumTotal = (entries || []).reduce((sum, [, count]) => sum + count, 0);\n  }\n\n  uniqueCount() {\n    return this.map.size;\n  }\n\n  totalCount() {\n    return this.sumTotal;\n  }\n\n  entries() {\n    return [...this.map.entries()];\n  }\n\n  uniqueValues() {\n    return [...this.map.keys()];\n  }\n\n  static merge(...dists: Distribution[]) {\n    const merged = new Distribution();\n    const m = merged.map;\n    dists.forEach((dist) => {\n      dist.map.forEach((c, v) => m.set(v, (m.get(v) || 0) + c));\n      merged.sumTotal += dist.sumTotal;\n    });\n    return merged;\n  }\n}\n\nexport class MutableDistribution extends Distribution {\n  increment(value: number) {\n    this.map.set(value, (this.map.get(value) || 0) + 1);\n    this.sumTotal += 1;\n  }\n\n  toImmutable() {\n    return new Distribution(this.entries());\n  }\n}\n\nexport default Distribution;\n"],"names":["_arrayLikeToArray","arr","len","length","i","arr2","Array","_unsupportedIterableToArray","o","minLen","n","Object","prototype","toString","call","slice","constructor","name","from","test","isArray","_i","Symbol","iterator","_s","_e","_arr","_n","_d","next","done","push","value","err","TypeError","_createForOfIteratorHelper","allowArrayLike","it","F","s","e","f","normalCompletion","didErr","step","_e2","_toConsumableArray","iter","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","Expression","typeName","expr","subExprs","evalFunc","rawExpression","subExpressions","this","state","ExpressionCreator","params","regex","globalRegex","parseFunc","numOperands","sample","description","gFlags","flags","RegExp","source","match","Error","randomFunction","Math","random","NoPF","sum","values","reduce","prev","cur","roll","die","floor","expressionUtils","splitExpr","checkType","type_names","includes","SplitExpressions","ctx","eval","m","exprs","storedType","funcName","funcReg","set","varName","varReg","get","critmin","Number","vantage","num","droll","rolls","start","stop","undefined","result","range","abs","map","max","min","critMiss","critHit","ac","pushCrit","popCrit","successmod","dmg","sm","a","unaryExpr","UnaryExpressions","valueExpr","rollOperations","kh","param","sort","b","kl","rrle","ds","forEach","v","rrlt","rrge","rrgt","rreq","rollOpRegex","keys","join","ValueExpressions","crittable","dieSize","numDice","operations","matchAll","om","operation","numWithCrit","crit","pb","level","operatorExpressions","matchAt","matches","index","appendChunk","chunk","resets","startsWith","endsWith","substring","operator","braces","currentChunk","chunkParensResets","opMatch","curChar","filter","Boolean","parseSimExpr","rawExpr","exprCreator","parts","parensGroups","create","exec","SimState","config","critStack","Map","pop","newCrit","clear","_setPrototypeOf","p","setPrototypeOf","__proto__","_inherits","subClass","superClass","_getPrototypeOf","getPrototypeOf","_typeof","obj","_possibleConstructorReturn","self","ReferenceError","_createSuper","Derived","hasNativeReflectConstruct","Reflect","construct","sham","Proxy","valueOf","Super","NewTarget","arguments","apply","simulation","simParams","BaseSimulation","rootExpr","rootExpression","initialState","Distribution","entries","sumTotal","size","merged","dists","dist","c","MutableDistribution","onmessage","event","data","command","expression","distribution","iterations","results","reset","increment","run","toImmutable","runSims","postMessage"],"sourceRoot":""}