{"version":3,"file":"static/js/50.ba90c760.chunk.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","sim/Expression.ts","sim/ExpressionCreator.ts","sim/expressions.ts","util/range.ts","sim/parse.ts","sim/SimState.ts","sim/Simulation.ts","worker/worker.ts","sim/Stats.ts"],"sourcesContent":["export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","import SimState from './SimState';\n\nexport type EvalFunc<T> = (s: SimState, ctx: Expression<T>) => number;\n\nexport default class Expression<T = unknown> {\n  typeName: string;\n  rawExpression: string;\n  subExpressions: Expression[];\n  evalFunc: EvalFunc<T>;\n  props: T;\n\n  constructor(typeName: string, expr: string, subExprs: Expression[], evalFunc: EvalFunc<T>, props: T) {\n    this.typeName = typeName;\n    this.rawExpression = expr;\n    this.subExpressions = subExprs;\n    this.evalFunc = evalFunc;\n    this.props = props;\n  }\n\n  eval(state: SimState): number {\n    return this.evalFunc(state, this);\n  }\n}\n","import Expression, { EvalFunc } from './Expression';\n\nexport type ParseFunc<T> = (match: RegExpExecArray, subExprs: Expression[]) => T;\n\nexport default class ExpressionCreator<T> {\n  typeName: string;\n  regex: RegExp;\n  parseFunc: ParseFunc<T>;\n  evalFunc: EvalFunc<T>;\n  min: number; \n  max?: number;\n\n  constructor(typeName: string, regex: RegExp, min: number, max: number, parseFunc: ParseFunc<T>, evalFunc: EvalFunc<T>) {\n    this.typeName = typeName\n    this.regex = regex;\n    this.parseFunc = parseFunc\n    this.evalFunc = evalFunc;\n    this.min = min; \n    this.max = max;\n  }\n\n  create(expr: string, subExprs: Expression[]) {\n    if ((this.min && subExprs.length < this.min) || (this.max && subExprs.length > this.max)) {\n      throw Error(`Invalid syntax in \"${expr}\": ${this.typeName} expected between ${this.min} and ${this.max} operands but got ${subExprs.length}`);\n    }\n    let matches: RegExpExecArray | null;\n    // This is pretty hacky, but works for now...\n    if (subExprs.length > 0) {\n      matches = this.regex.exec(expr.substring(subExprs[0].rawExpression.length));\n    } else {\n      matches = this.regex.exec(expr);\n    }\n    if (!matches) {\n      throw new Error(`Unexpected match failure for ${this.typeName} in \"${expr}\"`);\n    }\n    const props: T = this.parseFunc(matches, subExprs);\n    return new Expression(this.typeName, expr, subExprs, this.evalFunc, props);\n  }\n}\n","import { range } from 'util/range';\nimport ExpressionCreator, { ParseFunc } from './ExpressionCreator';\nimport Expression, { EvalFunc } from './Expression';\n\nconst NoPF = () => ({});\nconst NoMax = 999;\n\n\nfunction splitExpr<T>(typeName: string, regex: RegExp, maxSubExprs: number, parseFunc: ParseFunc<T>, evalFunc: EvalFunc<T>) {\n  return new ExpressionCreator(typeName, regex, 2, maxSubExprs, parseFunc, evalFunc);\n}\n\nfunction valueExpr<T>(typeName: string, regex: RegExp, parseFunc: ParseFunc<T>, evalFunc: EvalFunc<T>) {\n  return new ExpressionCreator(typeName, regex, 0, 0, parseFunc, evalFunc);\n}\n\nlet randomFunction = Math.random;\nconst sum = (values: number[]) => values.reduce((prev, cur) => prev + cur, 0);\nconst roll = (die: number) => Math.floor(randomFunction() * die) + 1;\n\nconst checkType = (expr: Expression, type_names: string[]) => {\n  if (!type_names.includes(expr.typeName)) {\n    throw Error(`Type of \"${expr.rawExpression}\" was expected to be one of \"${type_names}\", but was \"${expr.typeName}\"`)\n  }\n  return expr.typeName;\n}\n\nconst parseVantage = (vantage: string, num?: string) => {\n  if (vantage === 'adv') {\n    return Number(num || 2)\n  } else if (vantage === 'dis') {\n    return -Number(num || 2)\n  }\n  return 0;\n};\n\nexport const SplitExpressions = [\n  splitExpr('assign', /:=/, 2,\n    (m, exprs) => ({ storedType: checkType(exprs[0], ['variable', 'function']) }),\n    (s, ctx) => {\n      if (ctx.props.storedType === 'function') {\n        const funcName = (ctx.subExpressions[0].props as { funcName: string })?.funcName;\n        s.funcReg.set(funcName, ctx.subExpressions[1]);\n      } else if (ctx.props.storedType === 'variable') {\n        const varName = (ctx.subExpressions[0].props as { varName: string })?.varName;\n        s.varReg.set(varName, ctx.subExpressions[1].eval(s));\n      }\n      return 0;\n    },\n  ),\n  splitExpr('check', /=>/, 2, NoPF, (s, ctx) => (ctx.subExpressions[0].eval(s) ? ctx.subExpressions[1].eval(s) : 0)),\n  splitExpr('attack', /=atk(?::(\\d+))?(?::(adv|dis)(\\d+)?)?>/, 2,\n    (m) => ({ critmin: Number(m[1] || 20), vantage: parseVantage(m[2], m[3]) }),\n    (state, { props, subExpressions }) => {\n      let droll = roll(20);\n      if (props.vantage > 1 || props.vantage < -1) {\n        const rolls = range(Math.abs(props.vantage) - 1).map(() => roll(20));\n        const reducer = props.vantage > 0 ? Math.max : Math.min;\n        droll = reducer(droll, ...rolls);\n      }\n      const crit = droll >= props.critmin;\n      if (crit || (subExpressions[0].eval(state) + droll >= state.ac)) {\n        state.pushCrit(crit);\n        const result = subExpressions[1].eval(state);\n        state.popCrit();\n        return result;\n      }\n      return 0;\n    }\n  ),\n  splitExpr('save', /=sav:(\\d+)(?::(adv|dis))?>/, 2,\n    (m) => ({ successmod: (Number(m[1]) / 100.0) ?? 0.5, vantage: m[2] }),\n    (state, ctx) => {\n      let droll = roll(20);\n      if (ctx.props.vantage === 'adv') {\n        droll = Math.max(droll, roll(20));\n      } else if (ctx.props.vantage === 'dis') {\n        droll = Math.min(droll, roll(20));\n      }\n\n      const dmg = ctx.subExpressions[1].eval(state)\n      if (droll + state.sm >= ctx.subExpressions[0].eval(state)) {\n        return Math.floor(dmg * ctx.props.successmod);\n      }\n      return dmg;\n    }\n  ),\n  splitExpr('gte', />=/, 2, NoPF, (s, ctx) => Number(ctx.subExpressions[0].eval(s) >= ctx.subExpressions[1].eval(s))),\n  splitExpr('lte', /<=/, 2, NoPF, (s, ctx) => Number(ctx.subExpressions[0].eval(s) <= ctx.subExpressions[1].eval(s))),\n  splitExpr('add', /\\+/, NoMax, NoPF, (s, ctx) => sum(ctx.subExpressions.map((e) => e.eval(s)))),\n  splitExpr('sub', /-(?!>)/, NoMax, NoPF, (s, ctx) => ctx.subExpressions[0].eval(s) - sum(ctx.subExpressions.slice(1).map((e) => e.eval(s)))),\n  splitExpr('mul', /\\*/, NoMax, NoPF, (s, ctx) => ctx.subExpressions.reduce((a, e) => a * e.eval(s), 1)),\n  splitExpr('div', /\\//, 2, NoPF, (s, ctx) => Math.floor(ctx.subExpressions[0].eval(s) / ctx.subExpressions[1].eval(s)) ),\n  splitExpr('repeat', /#/, 2, NoPF, (s, ctx) => sum([...new Array(Number(ctx.subExpressions[0].eval(s)))].map(() => ctx.subExpressions[1].eval(s)))),\n  splitExpr('reroll_lte', /@rrlte:/, 2, NoPF, (state, ctx) => {\n    let droll = ctx.subExpressions[0].eval(state);\n    if (droll <= ctx.subExpressions[1].eval(state)) {\n      return ctx.subExpressions[0].eval(state)\n    }\n    return droll;\n  }),\n];\n\nexport const ValueExpressions = [\n  valueExpr('number', /^\\d+$/, (m) => ({ value: Number(m[0]) }), (s, { props }) => props.value),\n  valueExpr('roll', /^(\\d*)d(\\d+)(?:k(h|l)(\\d+))?$/,\n    (m) => ({\n      dice: new Array(Number(m[1] || 1)).fill(Number(m[2])),\n      keep: (m[3] === 'l' ? -1 : 1) * Number(m[4] || m[1] || 1),\n    }),\n    (s, { props }) => {\n      const sortedRolls = props.dice.map(roll).sort((a, b) => (b - a) * Math.sign(props.keep));\n      const keptRolls = sortedRolls.slice(0, Math.abs(props.keep || props.dice.length));\n      return sum(keptRolls);\n    },\n  ),\n  valueExpr('roll_crit', /^(\\d*)D(\\d+)?$/,\n    (m) => ({ dice: new Array(Number(m[1] || 1)).fill(Number(m[2])) }),\n    (s, { props }) => sum(props.dice.map((d) => roll(d) + (s.crit() ? roll(d) : 0))),\n  ),\n  valueExpr('armor_class', /^AC$/, NoPF, (s, ctx) => s.ac),\n  valueExpr('prof_bonus', /^PB$/, NoPF, (s, ctx) => s.pb),\n  valueExpr('level', /^LV$/, NoPF, (s, ctx) => s.level),\n  valueExpr('crit_mult', /^CM$/, NoPF, (s, ctx) => Number(s.crit()) * 1 + 1),\n  valueExpr('crit_binary', /^CB$/, NoPF, (s, ctx) => Number(s.crit()) * 1),\n  valueExpr('empty', /^$/, NoPF, (s, ctx) => 0 ),\n  valueExpr('variable', /^\\$([\\d\\w]+)$/,\n    (m) => ({ varName: m[1] }),\n    (s, ctx) => s.varReg.get(ctx.props.varName) || 0,\n  ),\n  valueExpr('function', /^@([\\d\\w]+)$/,\n    (m) => ({ funcName: m[1] }),\n    (s, ctx) => s.funcReg.get(ctx.props.funcName)?.eval(s) || 0,\n  ),\n];\n\nexport const exportedForTesting = {\n  setRandomFunction: (func: () => number) => randomFunction = func,\n};\n","\nexport function range(stop: number): number[];\nexport function range(start: number, stop: number): number[];\nexport function range(start: number, stop: number, step: number): number[];\nexport function range(start: number, stop?: number, step?: number): number[] {\n  if (stop === undefined) {\n      // one param defined\n      stop = start;\n      start = 0;\n  }\n\n  if (step === undefined) {\n      step = 1;\n  }\n\n  if ((step > 0 && start >= stop) || (step < 0 && start <= stop)) {\n      return [];\n  }\n\n  var result = [];\n  for (var i = start; step > 0 ? i < stop : i > stop; i += step) {\n      result.push(i);\n  }\n\n  return result;\n};\n","import parseRanges from 'util/parseRanges';\nimport Expression from './Expression';\nimport { SplitExpressions, ValueExpressions } from './expressions';\nimport SimState from './SimState';\nimport Simulation from './Simulation';\n\nfunction regexMatchAt(regex: RegExp, str: string, index: number): string | undefined {\n  const m = regex.exec(str.substring(index));\n  return (m?.index === 0 || undefined) && m?.[0];\n}\n\nfunction appendChunk(result: string[], chunk: string, resets: number) {\n  if (resets === 1 && chunk.startsWith('(') && chunk.endsWith(')')) {\n    chunk = chunk.substring(1, chunk.length - 1);\n  }\n  result.push(chunk);\n}\n\nfunction splitExpr(expr: string, opRegex: RegExp): [string[], number] {\n  const result: string[] = [];\n  let braces = 0;\n  let currentChunk = '';\n  let chunkParensResets = 0;\n  let i = 0;\n  while (i < expr.length) {\n    const curChar = expr[i]\n    if (curChar === '(') {\n      braces += 1;\n    } else if (curChar === ')') {\n      braces -= 1;\n      if (braces === 0) {\n        chunkParensResets += 1;\n      }\n    }\n    const opMatch = regexMatchAt(opRegex, expr, i)\n    if (braces === 0 && opMatch) {\n        appendChunk(result, currentChunk, chunkParensResets);\n        currentChunk = '';\n        chunkParensResets = 0;\n        i += opMatch.length;\n    } else {\n      currentChunk += curChar;\n      i += 1;\n    }\n  }\n  if (braces !== 0) {\n    throw Error(`Unbalanced parentheses in expression \"${expr}\"`);\n  }\n  appendChunk(result, currentChunk, chunkParensResets)\n  return [result, chunkParensResets]\n}\n\nexport function parseSimExpr(rawExpr: string): Expression {\n  for (let exprCreator of SplitExpressions) {\n    const [parts, parensGroups] = splitExpr(rawExpr, exprCreator.regex)\n    if (parts.length === 1 && parensGroups === 1 && rawExpr.startsWith('(') && rawExpr.endsWith(')')) {\n      return parseSimExpr(parts[0])\n    }\n    if (parts.length > 1) {\n      return exprCreator.create(rawExpr, parts.map(parseSimExpr)) as Expression;\n    }\n  }\n\n  for (let exprCreator of ValueExpressions) {\n    if (exprCreator.regex.exec(rawExpr)) {\n      return exprCreator.create(rawExpr, []) as Expression;\n    }\n  }\n\n  throw Error(`Invalid expression: \"${rawExpr}\"`)\n}\n\nexport function parseSimDef(simDef: string): Simulation[] {\n  const [nameLevel, expr] = simDef.split(/:(.*)/);\n  if (!expr) {\n    throw new Error(`Simulation definition \"${simDef}\" is not correctly formatted.`)\n  }\n  let levels = [0];\n  let name = nameLevel;\n  if (nameLevel.includes('@')) {\n    const [namePart, levelsPart] = name.split('@');\n    name = namePart;\n    levels = parseRanges([levelsPart]);\n  }\n  let expression: Expression<unknown>;\n  let error: string | undefined;\n  const rawExpr = expr.replace(/ /g, '');\n  try {\n    expression = parseSimExpr(rawExpr);\n  } catch (e) {\n    expression = parseSimExpr('0');\n    error = String(e);\n  }\n  return levels.map((level) => {\n    const sim = new Simulation(name, level, simDef, rawExpr, expression);\n    sim.error = error;\n    return sim;\n  });\n}\n\nexport function tryParseTestSimDef(simDef: string): Simulation[] {\n  const sims = parseSimDef(simDef);\n  sims.forEach((sim) => {\n    if (!sim.error) {\n      try {\n        // Perform a test run, to make sure it's all good!\n        sim.run(new SimState({ ac: 10, pb: 2, level: 1, sm: 0 }));\n      } catch (e) {\n        sim.error = String(e);\n      }\n    }\n  });\n  return sims;\n}\n\nexport function parseTestSimDef(simDef: string): Simulation[] {\n  const sims = tryParseTestSimDef(simDef);\n  const firstError = sims.find((s) => s.error)?.error;\n  if (firstError) {\n    throw new Error(firstError);\n  }\n  return sims;\n}\n","import Expression from './Expression';\nimport SimParams from './SimParams';\n\nclass SimState implements SimParams {\n  // Static state\n  readonly ac: number;\n  readonly level: number;\n  readonly pb: number;\n  readonly sm: number;\n\n  // Dynamic state\n  readonly critStack: boolean[];\n  readonly funcReg: Map<string, Expression>;\n  readonly varReg: Map<string, number>;\n\n  constructor(config: SimParams) {\n    this.ac = config.ac;\n    this.sm = config.sm;\n    this.pb = config.pb;\n    this.level = config.level;\n\n    this.varReg = new Map();\n    this.funcReg = new Map();\n    this.critStack = [];\n  }\n\n  crit() {\n    return !!this.critStack[this.critStack.length - 1];\n  }\n\n  popCrit() {\n    this.critStack.pop();\n  }\n\n  pushCrit(newCrit: boolean) {\n    this.critStack.push(newCrit);\n  }\n\n  reset() {\n    this.critStack.length = 0;\n    this.funcReg.clear();\n    this.varReg.clear();\n  }\n}\n\nexport default SimState;\n","import Expression from './Expression';\nimport SimState from './SimState';\n\nexport class BaseSimulation {\n  rawExpression: string;\n  rootExpression: Expression;\n\n  constructor(rawExpr: string, rootExpr: Expression) {\n    this.rawExpression = rawExpr\n    this.rootExpression = rootExpr\n  }\n\n  run(initialState: SimState) {\n    return this.rootExpression.eval(initialState)\n  }\n}\n\nexport default class Simulation extends BaseSimulation {\n  name: string;\n  level: number;\n  simDefinition: string;\n  error?: string;\n\n  constructor(name: string, level: number, simDef: string, rawExpr: string, rootExpr: Expression) {\n    super(rawExpr, rootExpr);\n    this.name = name;\n    this.level = level;\n    this.simDefinition = simDef;\n    this.error = undefined;\n  }\n  \n  id() {\n    return `${this.name}@${this.level}`;\n  }\n\n  isValid() {\n    return !this.error;\n  }\n}\n","import { parseSimExpr } from 'sim/parse';\nimport SimParams from 'sim/SimParams';\nimport SimState from 'sim/SimState';\nimport { BaseSimulation } from 'sim/Simulation';\nimport calculateStats from 'sim/Stats';\nimport { ToWorkerMessages } from './Messages';\n\n// Each worker will be effectively run in a separate interpreter, so global\n// state isn't actually very global; each worker will have their own copy of\n// the below state\nlet simulation: BaseSimulation | undefined;\nlet simParams: SimParams | undefined;\n\nonmessage = function(event: MessageEvent<ToWorkerMessages>) {\n  const { data } = event;\n  if (data.command === 'configure') {\n    const { expression, config } = data;\n    simulation = new BaseSimulation(expression, parseSimExpr(expression));\n    simParams = config;\n  } else if (data.command === 'run') {\n    const { iterations } = data;\n    const stats = runSims(iterations);\n    this.postMessage({ command: 'complete', stats });\n  }\n}\n\nfunction runSims(iterations: number) {\n  if (!simulation || !simParams) throw new Error('Worker is not configured!');\n  const results: number[] = [];\n  const state = new SimState(simParams);\n  for (let i = 0; i < iterations; i++) {\n    state.reset();\n    results.push(simulation.run(state));\n  }\n  return calculateStats(results);\n}\n\nexport {}\n","export interface Stats {\n  count: number;\n  min: number;\n  max: number;\n  mean: number;\n  // squareMean: number;\n  stdev: number;\n}\n\nexport function combineStats(stats: Stats[]): Stats {\n  const count = stats.reduce((prev, curr) => prev + curr.count, 0);\n  const min = Math.min(...stats.map((s) => s.min));\n  const max = Math.max(...stats.map((s) => s.max));\n  const mean = stats.reduce((prev, curr) => prev + (curr.count * curr.mean), 0) / count;\n  // const squareMean = stats.reduce((prev, curr) => prev + curr.squareMean, 0);\n  // const stdev = Math.sqrt((squareMean / count) - (mean * mean)),\n  const stdevStats = stats.filter((s) => s.count > 1);\n  const stdev = Math.sqrt(stdevStats.reduce((prev, curr) => prev + (curr.count * (curr.stdev ** 2)), 0) / count);\n  return {\n    count,\n    min,\n    max,\n    mean,\n    // squareMean,\n    stdev,\n  };\n};\n\nexport default function calculateStats(values: number[]): Stats {\n  if (!values.length) throw Error('Cannot calculate stats for empty array');\n  const mean = values.reduce((s, n) => s + n) / values.length;\n  return {\n    count: values.length,\n    min: Math.min(...values),\n    max: Math.max(...values),\n    mean,\n    // squareMean: values.reduce((s, n) => s + (n * n), 0),\n    stdev: Math.sqrt(values.reduce((s, n) => s + (n - mean) ** 2, 0) / (values.length - 1)),\n  };\n};\n"],"names":["_arrayLikeToArray","arr","len","length","i","arr2","Array","_unsupportedIterableToArray","o","minLen","n","Object","prototype","toString","call","slice","constructor","name","from","test","isArray","_i","Symbol","iterator","_s","_e","_arr","_n","_d","next","done","push","value","err","TypeError","_createForOfIteratorHelper","allowArrayLike","it","F","s","e","f","normalCompletion","didErr","step","_e2","iter","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","Expression","typeName","expr","subExprs","evalFunc","rawExpression","subExpressions","this","state","ExpressionCreator","regex","min","max","parseFunc","Error","matches","exec","substring","NoPF","splitExpr","maxSubExprs","valueExpr","randomFunction","Math","random","sum","values","reduce","prev","cur","roll","die","floor","checkType","type_names","includes","SplitExpressions","m","exprs","storedType","ctx","funcName","funcReg","set","varName","varReg","eval","critmin","Number","vantage","num","droll","rolls","start","stop","undefined","result","range","abs","map","crit","ac","pushCrit","popCrit","successmod","dmg","sm","a","ValueExpressions","dice","fill","keep","keptRolls","sort","b","sign","d","pb","level","get","regexMatchAt","str","index","appendChunk","chunk","resets","startsWith","endsWith","opRegex","braces","currentChunk","chunkParensResets","curChar","opMatch","parseSimExpr","rawExpr","exprCreator","parts","parensGroups","create","SimState","config","critStack","Map","pop","newCrit","clear","simulation","simParams","BaseSimulation","rootExpr","rootExpression","initialState","onmessage","event","data","command","expression","stats","iterations","results","reset","run","mean","count","stdev","sqrt","calculateStats","runSims","postMessage"],"sourceRoot":""}