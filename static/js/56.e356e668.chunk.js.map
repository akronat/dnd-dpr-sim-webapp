{"version":3,"file":"static/js/56.e356e668.chunk.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","sim/expressions/Expression.ts","sim/expressions/ExpressionCreator.ts","sim/expressions/expressionUtils.ts","sim/expressions/splitExpressions.ts","util/range.ts","sim/expressions/valueExpressions.ts","sim/parse.ts","sim/SimState.ts","../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/inherits.js","../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/@babel/runtime/helpers/esm/createSuper.js","../node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","sim/Simulation.ts","worker/worker.ts","util/Distribution.ts"],"sourcesContent":["export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","import SimState from '../SimState';\n\nexport type EvalFunc<T> = (s: SimState, ctx: Expression<T>) => number;\n\nexport default class Expression<T = unknown> {\n  typeName: string;\n  rawExpression: string;\n  subExpressions: Expression[];\n  evalFunc: EvalFunc<T>;\n  props: T;\n\n  constructor(typeName: string, expr: string, subExprs: Expression[], evalFunc: EvalFunc<T>, props: T) {\n    this.typeName = typeName;\n    this.rawExpression = expr;\n    this.subExpressions = subExprs;\n    this.evalFunc = evalFunc;\n    this.props = props;\n  }\n\n  eval(state: SimState): number {\n    return this.evalFunc(state, this);\n  }\n}\n","import Expression, { EvalFunc } from './Expression';\n\nexport type ParseFunc<T> = (match: RegExpExecArray, subExprs: Expression[]) => T;\n\ninterface ExpressionParams<T> {\n  typeName: string;\n  regex: RegExp;\n  minSubExprs?: number;\n  maxSubExprs?: number;\n  parseFunc: ParseFunc<T>;\n  evalFunc: EvalFunc<T>;\n  sample: string;\n  description: string;\n}\n\nexport default class ExpressionCreator<T> {\n  typeName: string;\n  regex: RegExp;\n  parseFunc: ParseFunc<T>;\n  evalFunc: EvalFunc<T>;\n  min: number; \n  max: number;\n  sample: string;\n  description: string;\n\n  constructor(params: ExpressionParams<T>) {\n    this.typeName = params.typeName;\n    this.regex = params.regex;\n    this.parseFunc = params.parseFunc\n    this.evalFunc = params.evalFunc;\n    this.min = params.minSubExprs || 0; \n    this.max = params.maxSubExprs || 0;\n\n    this.sample = params.sample;\n    this.description = params.description;\n  }\n\n  create(expr: string, subExprs: Expression[]) {\n    if ((this.min && subExprs.length < this.min) || (this.max && subExprs.length > this.max)) {\n      throw Error(`Invalid syntax in \"${expr}\": ${this.typeName} expected between ${this.min} and ${this.max} operands but got ${subExprs.length}`);\n    }\n    let matches: RegExpExecArray | null;\n    // This is pretty hacky, but works for now...\n    if (subExprs.length > 0) {\n      matches = this.regex.exec(expr.substring(subExprs[0].rawExpression.length));\n    } else {\n      matches = this.regex.exec(expr);\n    }\n    if (!matches) {\n      throw new Error(`Unexpected match failure for ${this.typeName} in \"${expr}\"`);\n    }\n    const props: T = this.parseFunc(matches, subExprs);\n    return new Expression(this.typeName, expr, subExprs, this.evalFunc, props);\n  }\n}\n","const NoPF = () => ({});\nconst NoMax = 999;\n\nlet randomFunction = Math.random;\nconst sum = (values: number[]) => values.reduce((prev, cur) => prev + cur, 0);\nconst roll = (die: number) => Math.floor(randomFunction() * die) + 1;\n\nexport const exportedForTesting = {\n  setRandomFunction: (func: () => number) => randomFunction = func,\n};\n\nconst expressionUtils = { NoPF, NoMax, sum, roll };\n\nexport default expressionUtils;\n","import { range } from 'util/range';\nimport ExpressionCreator, { ParseFunc } from './ExpressionCreator';\nimport Expression, { EvalFunc } from './Expression';\nimport expressionUtils from './expressionUtils';\n\nconst { NoPF, NoMax, sum, roll } = expressionUtils;\n\nfunction splitExpr<T>(\n  typeName: string,\n  sample: string,\n  regex: RegExp,\n  maxSubExprs: number,\n  parseFunc: ParseFunc<T>,\n  evalFunc: EvalFunc<T>,\n  description: string,\n) {\n  return new ExpressionCreator({\n    typeName,\n    regex,\n    minSubExprs: 2,\n    maxSubExprs,\n    parseFunc,\n    evalFunc,\n    description,\n    sample\n  });\n}\n\nconst checkType = (expr: Expression, type_names: string[]) => {\n  if (!type_names.includes(expr.typeName)) {\n    throw Error(`Type of \"${expr.rawExpression}\" was expected to be one of \"${type_names}\", but was \"${expr.typeName}\"`)\n  }\n  return expr.typeName;\n}\n\nconst parseVantage = (vantage: string, num?: string) => {\n  if (vantage === 'adv') {\n    return Number(num || 2)\n  } else if (vantage === 'dis') {\n    return -Number(num || 2)\n  }\n  return 0;\n};\n\nexport const SplitExpressions = [\n  splitExpr('Assign', ':=', /:=/, 2,\n    (m, exprs) => ({ storedType: checkType(exprs[0], ['Variable', 'Function']) }),\n    (s, ctx) => {\n      if (ctx.props.storedType === 'Function') {\n        const funcName = (ctx.subExpressions[0].props as { funcName: string })?.funcName;\n        s.funcReg.set(funcName, ctx.subExpressions[1]);\n      } else if (ctx.props.storedType === 'Variable') {\n        const varName = (ctx.subExpressions[0].props as { varName: string })?.varName;\n        s.varReg.set(varName, ctx.subExpressions[1].eval(s));\n      }\n      return 0;\n    },\n    `Assign value to variable or sub expression to function. Output is 0.\n\nFor example:\n  $a := 1d6\nIn the above, the outcome of the 1d6 roll will be assigned to $a for later use. \\\nThis can be useful in cases where you need to know the outcome of an earlier \\\nattack, such as whether you've already used your sneak attack for the turn:\n  ($a := (3+PB =atk> 1D6+3 + 1D6)) + (3+PB =atk> 1D6 + ($a<=0 => 1D6)) + $a\n\nCan also assign a sub expression as a function:\n  @a := 3+PB =atk> 1D6+3\nIn the above, the attack sub expression is assigned to $a for later use. Each \\\ntime it is used later, it will be re-evaluated (dice will be rolled again). \\\nThis can be useful in cases where you want to evaluate the same thing multiple \\\ntimes, like sneak attack after each attack:\n  (@sa := $sd<=0 => ($sd:=1D6)+$sd) + (3+PB =atk> 1D6+3 + @sa) + (3+PB =atk> 1D6 + @s) + $sd\n`,\n  ),\n  splitExpr('Check', '=>', /=>/, 2, NoPF, (s, ctx) => (ctx.subExpressions[0].eval(s) ? ctx.subExpressions[1].eval(s) : 0),\n    `If left operand is non-zero, then output the right operand, otherwise \\\noutput 0. For example:\n  1d20 <= 11 => 1d8`\n  ),\n  splitExpr('Attack', '=atk>', /=atk(?::(\\d+))?(?::(adv|dis)(\\d+)?)?>/, 2,\n    (m) => ({ critmin: Number(m[1] || 20), vantage: parseVantage(m[2], m[3]) }),\n    (state, { props, subExpressions }) => {\n      let droll = roll(20);\n      if (props.vantage > 1 || props.vantage < -1) {\n        const rolls = range(Math.abs(props.vantage) - 1).map(() => roll(20));\n        const reducer = props.vantage > 0 ? Math.max : Math.min;\n        droll = reducer(droll, ...rolls);\n      }\n      const crit = droll >= props.critmin;\n      if (crit || (subExpressions[0].eval(state) + droll >= state.ac)) {\n        state.pushCrit(crit);\n        const result = subExpressions[1].eval(state);\n        state.popCrit();\n        return result;\n      }\n      return 0;\n    },\n    `Make an attack. The left operand will be added to the d20 roll, and if \\\nthe result meets the AC then the output is the right operand. For example:\n  3+PB =atk> 1D6+3\nThe above is mostly equivalent to:\n  (3+PB + 1d20 >= AC) => 1D6+3\nHowever, the =atk> operator also accounts for crits. If the d20 rolled for the \\\nattack is a 20, then the critical hit flag is set (the number of dice rolled in \\\nthe 1D6 damage roll will then be doubled; note that the doubling of dice only \\\napplies when the uppercase D is used. Using a lowercase d will not double dice).\n\nCan also specify that the attack be made with advantage or disadvantage:\n  3+PB =atk:adv> 1D6+3\n  3+PB =atk:dis> 1D6+3\nOr even super advantage or disadvantage:\n  3+PB =atk:adv3> 1D6+3\n  3+PB =atk:dis3> 1D6+3\n\nCan also specify the minimum critical hit threshold, for example if you can \\\ncrit on a 19:\n  3+PB =atk:19> 1D6+3\n\nNote that if you specify both adv/dis and crit threshold, the crit threshold \\\nshould come first:\n3+PB =atk:19:dis> 1D6+3`,\n  ),\n  splitExpr('Save', '=sav>', /=sav:(\\d+)(?::(adv|dis))?>/, 2,\n    (m) => ({ successmod: (Number(m[1]) / 100.0) ?? 0.5, vantage: m[2] }),\n    (state, ctx) => {\n      let droll = roll(20);\n      if (ctx.props.vantage === 'adv') {\n        droll = Math.max(droll, roll(20));\n      } else if (ctx.props.vantage === 'dis') {\n        droll = Math.min(droll, roll(20));\n      }\n\n      const dmg = ctx.subExpressions[1].eval(state)\n      if (droll + state.sm >= ctx.subExpressions[0].eval(state)) {\n        return Math.floor(dmg * ctx.props.successmod);\n      }\n      return dmg;\n    },\n    `Have the target make a saving throw. The left operand is the difficulty \\\nclass (DC) of the save; if the target save (1d20 + SM) does not meet the DC, \\\nthen the output will be the right operand. Otherwise, if the target save does \\\nmeet the DC, then the output will be half the right operand. For example:\n  8+3+PB =sav> 3d8\nThe above is equivalent to:\n  ($s := 1d20 + SM) + ($s < 8+3+PB => 3d8) + ($s >= 8+3+PB => 3d8/2)\n\nCan also specify that the save be made with advantage or disadvantage:\n  8+3+PB =sav:adv> 3d8\n  8+3+PB =sav:dis> 3d8\n\nCan also specify the output modifier for save success, for example if suceeding \\\non the save results in no damage being taken:\n  8+3+PB =sav:0> 3d8\nNote the the success modifier is specified as a positive integer percentage, so \\\na value of 25 would mean that the damage is quartered.\n\nNote that if you specify both adv/dis and success modifier, the success modifier \\\nshould come first:\n  8+3+PB =sav:0:adv> 3d8`,\n  ),\n  splitExpr('Greater Than Or Equal To', '>=', />=/, 2, NoPF,\n    (s, ctx) => Number(ctx.subExpressions[0].eval(s) >= ctx.subExpressions[1].eval(s)),\n    'Outputs 1 if the left operand is greater than or equal to the right operand, otherwise 0.',\n  ),\n  splitExpr('Greater Than', '>', /(?<!=)>(?!=)/, 2, NoPF,\n    (s, ctx) => Number(ctx.subExpressions[0].eval(s) > ctx.subExpressions[1].eval(s)),\n    'Outputs 1 if the left operand is greater than the right operand, otherwise 0.',\n  ),\n  splitExpr('Less Than Or Equal To', '<=', /<=/, 2, NoPF,\n    (s, ctx) => Number(ctx.subExpressions[0].eval(s) <= ctx.subExpressions[1].eval(s)),\n    'Outputs 1 if the left operand is less than or equal to the right operand, otherwise 0.',\n  ),\n  splitExpr('Less Than', '<', /(?<!=)<(?!=)/, 2, NoPF,\n    (s, ctx) => Number(ctx.subExpressions[0].eval(s) < ctx.subExpressions[1].eval(s)),\n    'Outputs 1 if the left operand is less than the right operand, otherwise 0.',\n  ),\n  splitExpr('Add', '+', /\\+/, NoMax, NoPF,\n    (s, ctx) => sum(ctx.subExpressions.map((e) => e.eval(s))),\n    'Outputs the sum of the left operand and right operand',\n  ),\n  splitExpr('Subtract', '-', /-(?!>)/, NoMax, NoPF,\n    (s, ctx) => ctx.subExpressions[0].eval(s) - sum(ctx.subExpressions.slice(1).map((e) => e.eval(s))),\n    'Outputs the result of subtracting the right operand from the left operand.',\n  ),\n  splitExpr('Multiply', '*', /\\*/, NoMax, NoPF,\n    (s, ctx) => ctx.subExpressions.reduce((a, e) => a * e.eval(s), 1),\n    'Outputs the result of multiplying the left operand by the right oeprand.',\n  ),\n  splitExpr('Divide', '/', /\\//, 2, NoPF,\n    (s, ctx) => Math.floor(ctx.subExpressions[0].eval(s) / ctx.subExpressions[1].eval(s)),\n    `Outputs the result of dividing the left operand by the right oeprand. \\\nDecimal results are rounded down the nearest whole integer.`,\n  ),\n  splitExpr('Repeat', '#', /#/, 2, NoPF,\n    (s, ctx) => sum([...new Array(Number(ctx.subExpressions[0].eval(s)))].map(() => ctx.subExpressions[1].eval(s))),\n    `Outputs the sum of repeating evaluation of the right operand a number of \\\ntimes equal to the left operand.`\n  ),\n  // TODO: Remove this at some point\n  splitExpr('Reroll (If Less Than Or Equal To)', '@rrlte:', /@rrlte:/, 2,\n    () => { throw new Error('@rrlte: has been removed; use the 2d6rrle2 syntax instead') },\n    () => { throw new Error('@rrlte: has been removed; use the 2d6rrle2 syntax instead') },\n    '',\n  ),\n];\n","\nexport function range(stop: number): number[];\nexport function range(start: number, stop: number): number[];\nexport function range(start: number, stop: number, step: number): number[];\nexport function range(start: number, stop?: number, step?: number): number[] {\n  if (stop === undefined) {\n      // one param defined\n      stop = start;\n      start = 0;\n  }\n\n  if (step === undefined) {\n      step = 1;\n  }\n\n  if ((step > 0 && start >= stop) || (step < 0 && start <= stop)) {\n      return [];\n  }\n\n  var result = [];\n  for (var i = start; step > 0 ? i < stop : i > stop; i += step) {\n      result.push(i);\n  }\n\n  return result;\n};\n","import ExpressionCreator, { ParseFunc } from './ExpressionCreator';\nimport { EvalFunc } from './Expression';\nimport expressionUtils from './expressionUtils';\n\nconst { NoPF, sum, roll } = expressionUtils;\n\nfunction valueExpr<T>(\n  typeName: string,\n  sample: string,\n  regex: RegExp,\n  parseFunc: ParseFunc<T>,\n  evalFunc: EvalFunc<T>,\n  description: string,\n) {\n  return new ExpressionCreator({\n    typeName,\n    regex,\n    parseFunc,\n    evalFunc,\n    description,\n    sample\n  });\n}\n\ntype RollOp = (rolls: number[], param: number, dieSize: number) => number[] | void;\nconst rollOperations: Record<string, RollOp> = {\n  kh: (rolls, param) => rolls.sort((a, b) => (b - a)).slice(0, param),\n  kl: (rolls, param) => rolls.sort((a, b) => (a - b)).slice(0, param),\n  rrle: (rolls, param, ds) => rolls.forEach((v, i, a) => { if (v <= param) a[i] = roll(ds); }),\n  rrlt: (rolls, param, ds) => rolls.forEach((v, i, a) => { if (v < param) a[i] = roll(ds); }),\n  rrge: (rolls, param, ds) => rolls.forEach((v, i, a) => { if (v >= param) a[i] = roll(ds); }),\n  rrgt: (rolls, param, ds) => rolls.forEach((v, i, a) => { if (v > param) a[i] = roll(ds); }),\n  rreq: (rolls, param, ds) => rolls.forEach((v, i, a) => { if (v === param) a[i] = roll(ds); }),\n};\nconst rollOpRegex = Object.keys(rollOperations).join('|');\n\nexport const ValueExpressions = [\n  valueExpr('Number', 'X', /^\\d+$/, (m) => ({ value: Number(m[0]) }), (s, { props }) => props.value,\n  'Where X is any positive integer. Outputs the value of the integer.',\n  ),\n  valueExpr('Roll Dice', 'XdY', new RegExp(`^(\\\\d*)([dD])(\\\\d+)((?:(?:${rollOpRegex})\\\\d+)*)$`),\n    (m) => {\n      return ({\n        crittable: m[2] === 'D',\n        dieSize: Number(m[3]),\n        numDice: Number(m[1] || 1),\n        operations: [...m[4].matchAll(/([a-zA-Z]+)(\\d+)/g)].map((om) => ({\n          operation: om[1],\n          param: Number(om[2]),\n        })),\n      });\n    },\n    (s, { props }) => {\n      const { crittable, dieSize, numDice, operations } = props;\n      let rolls: number[] = [];\n      const numWithCrit = (crittable && s.crit()) ? 2 * numDice : numDice;\n      for (let i = 0; i < numWithCrit; i += 1) {\n        rolls.push(roll(dieSize));\n      }\n      operations.forEach(({ operation, param }) => {\n        rolls = rollOperations[operation](rolls, param, dieSize) || rolls;\n      });\n      return sum(rolls);\n    },\n    `Where X and Y are any positive integers. Outputs the sum of rolls with a \\\ndice of size Y rolled X number of times. For example:\n  3d8\nIn the above, an 8 sided dice will be rolled 3 times, and the output will be \\\nthe sum of the results.\n\nCritical hits can be accounted for with an uppercase D to double the number of \\\ndice rolled on a critical hit:\n  3D8\nIn the above, if the critical hit flag is set  (in the right operand of an \\\nAttack where the attack roll was >= to the critical threshold), then an 8 sided \\\ndice will be rolled 6 times.\n\nCan also append additional modifier operations after the above basic rolls, \\\nsuch as \"keep highest\":\n  3d8kh2\nThe above rolls 3 d8s, and keeps the two highest rolls. To simulate the \"Great \\\nWeapon Fighting Style\" you could instead use rrle:\n  2D6rrle2\nWhich rolls 2 d6s (or 4 on a crit), and rerolls any 1s and 2s. Any number of \\\nthese operations can be appended, such as:\n  4d6kl2rrle2kh1\nWhich rolls 4 d6s, then keeps the lowest 2, then rerolls any of the remaining 2 \\\nthat are 2 or less, then keeps the highest 1 of those remaining 2.\n\nThe available modifier operations (where X is any positive integer) are:\n  khX: Keep the highest X dice\n  klX: Keep the lowest X dice\n  rrleX: Reroll (only once) any dice that are less than or equal to X\n  rrltX: Reroll (only once) any dice that are less than X\n  rrgeX: Reroll (only once) any dice that are greater than or equal to X\n  rrgtX: Reroll (only once) any dice that are greater than X\n  rreqX: Reroll (only once) any dice that are equal to X\n`\n  ),\n  valueExpr('Armor Class', 'AC', /^AC$/, NoPF, (s, ctx) => s.ac,\n    'Outputs the armor class of the target the simulation is being run against.'\n  ),\n  valueExpr('Save Modifier', 'SM', /^SM$/, NoPF, (s, ctx) => s.ac,\n    'Outputs the save modifier of the target the simulation is being run against.'\n  ),\n  valueExpr('Proficiency Bonus', 'PB', /^PB$/, NoPF, (s, ctx) => s.pb,\n    'Outputs the proficiency bonus for the level of the character build.'\n  ),\n  valueExpr('Level', 'LV', /^LV$/, NoPF, (s, ctx) => s.level,\n    'Outputs the level of the character build.'\n  ),\n  valueExpr('Critical Multiplier', 'CM', /^CM$/, NoPF, (s, ctx) => Number(s.crit()) * 1 + 1,\n    `Outputs 2 if critical flag is set (in the right operand of an Attack where \\\n  the attack roll was >= to the critical threshold), otherwise 1.`\n  ),\n  valueExpr('Critical Binary', 'CB', /^CB$/, NoPF, (s, ctx) => Number(s.crit()) * 1,\n    `Outputs 1 if critical flag is set (in the right operand of an Attack where \\\nthe attack roll was >= to the critical threshold), otherwise 0.`\n  ),\n  valueExpr('Empty', '', /^$/, NoPF, (s, ctx) => 0, ''),\n  valueExpr('Variable', '$X', /^\\$([\\d\\w]+)$/,\n    (m) => ({ varName: m[1] }),\n    (s, ctx) => s.varReg.get(ctx.props.varName) || 0,\n    `Where X is a string of alphanumeric characters. A variable that can be \\\nstored and retrieved. Outputs the value of the variable, which starts as 0. \\\nFor example:\n  $a := 1d6\nIn the above, the outcome of the 1d6 roll will be assigned to $a for later use. \\\nThis can be useful in cases where you need to know the outcome of an earlier \\\nattack, such as whether you've already used your sneak attack for the turn:\n  ($a := (3+PB =atk> 1D6+3 + 1D6)) + (3+PB =atk> 1D6 + ($a<=0 => 1D6)) + $a`,\n  ),\n  valueExpr('Function', '@X', /^@([\\d\\w]+)$/,\n    (m) => ({ funcName: m[1] }),\n    (s, ctx) => s.funcReg.get(ctx.props.funcName)?.eval(s) || 0,\n    `Where X is a string of alphanumeric characters. A function that can be \\\nassigned a sub expression and then later evaluated. \\\nOutputs the result of evaluating the sub expression (any dice rolls will be \\\nrerolled each time), or 0 if an expression has not yet been assigned. For \\\nexample:\n  @a := 3+PB =atk> 1D6+3\nIn the above, the attack sub expression is assigned to $a for later use. Each \\\ntime it is used later, it will be re-evaluated (dice will be rolled again). \\\nThis can be useful in cases where you want to evaluate the same thing multiple \\\ntimes, like sneak attack after each attack:\n  (@sa := $sd<=0 => ($sd:=1D6)+$sd) + (3+PB =atk> 1D6+3 + @sa) + (3+PB =atk> 1D6 + @s) + $sd`,\n  ),\n];\n","import parseRanges from 'util/parseRanges';\nimport Expression from './expressions/Expression';\nimport { SplitExpressions } from './expressions/splitExpressions';\nimport { ValueExpressions } from './expressions/valueExpressions';\nimport SimState from './SimState';\nimport Simulation from './Simulation';\n\nfunction regexMatchAt(regex: RegExp, str: string, index: number): string | undefined {\n  const m = regex.exec(str.substring(index));\n  return (m?.index === 0 || undefined) && m?.[0];\n}\n\nfunction appendChunk(result: string[], chunk: string, resets: number) {\n  if (resets === 1 && chunk.startsWith('(') && chunk.endsWith(')')) {\n    chunk = chunk.substring(1, chunk.length - 1);\n  }\n  result.push(chunk);\n}\n\nfunction splitExpr(expr: string, opRegex: RegExp): [string[], number] {\n  const result: string[] = [];\n  let braces = 0;\n  let currentChunk = '';\n  let chunkParensResets = 0;\n  let i = 0;\n  while (i < expr.length) {\n    const curChar = expr[i]\n    if (curChar === '(') {\n      braces += 1;\n    } else if (curChar === ')') {\n      braces -= 1;\n      if (braces === 0) {\n        chunkParensResets += 1;\n      }\n    }\n    const opMatch = regexMatchAt(opRegex, expr, i)\n    if (braces === 0 && opMatch) {\n        appendChunk(result, currentChunk, chunkParensResets);\n        currentChunk = '';\n        chunkParensResets = 0;\n        i += opMatch.length;\n    } else {\n      currentChunk += curChar;\n      i += 1;\n    }\n  }\n  if (braces !== 0) {\n    throw Error(`Unbalanced parentheses in expression \"${expr}\"`);\n  }\n  appendChunk(result, currentChunk, chunkParensResets)\n  return [result, chunkParensResets]\n}\n\nexport function parseSimExpr(rawExpr: string): Expression {\n  for (let exprCreator of SplitExpressions) {\n    const [parts, parensGroups] = splitExpr(rawExpr, exprCreator.regex)\n    if (parts.length === 1 && parensGroups === 1 && rawExpr.startsWith('(') && rawExpr.endsWith(')')) {\n      return parseSimExpr(parts[0])\n    }\n    if (parts.length > 1) {\n      return exprCreator.create(rawExpr, parts.map(parseSimExpr)) as Expression;\n    }\n  }\n\n  for (let exprCreator of ValueExpressions) {\n    if (exprCreator.regex.exec(rawExpr)) {\n      return exprCreator.create(rawExpr, []) as Expression;\n    }\n  }\n\n  throw Error(`Invalid expression: \"${rawExpr}\"`)\n}\n\nexport function parseSimDef(simDef: string): Simulation[] {\n  const [nameLevel, expr] = simDef.split(/:(.*)/);\n  if (!expr) {\n    throw new Error(`Simulation definition \"${simDef}\" is not correctly formatted.`)\n  }\n  let levels = [0];\n  let name = nameLevel;\n  if (nameLevel.includes('@')) {\n    const [namePart, levelsPart] = name.split('@');\n    name = namePart;\n    levels = parseRanges([levelsPart]);\n  }\n  let expression: Expression<unknown>;\n  let error: string | undefined;\n  const rawExpr = expr.replace(/ /g, '');\n  try {\n    expression = parseSimExpr(rawExpr);\n  } catch (e) {\n    expression = parseSimExpr('0');\n    error = String(e);\n  }\n  return levels.map((level) => {\n    const sim = new Simulation(name, level, simDef, rawExpr, expression);\n    sim.error = error;\n    return sim;\n  });\n}\n\nexport function tryParseTestSimDef(simDef: string): Simulation[] {\n  const sims = parseSimDef(simDef);\n  sims.forEach((sim) => {\n    if (!sim.error) {\n      try {\n        // Perform a test run, to make sure it's all good!\n        sim.run(new SimState({ ac: 10, pb: 2, level: 1, sm: 0 }));\n      } catch (e) {\n        sim.error = String(e);\n      }\n    }\n  });\n  return sims;\n}\n\nexport function parseTestSimDef(simDef: string): Simulation[] {\n  const sims = tryParseTestSimDef(simDef);\n  const firstError = sims.find((s) => s.error)?.error;\n  if (firstError) {\n    throw new Error(firstError);\n  }\n  return sims;\n}\n","import Expression from './expressions/Expression';\nimport SimParams from './SimParams';\n\nclass SimState implements SimParams {\n  // Static state\n  readonly ac: number;\n  readonly level: number;\n  readonly pb: number;\n  readonly sm: number;\n\n  // Dynamic state\n  readonly critStack: boolean[];\n  readonly funcReg: Map<string, Expression>;\n  readonly varReg: Map<string, number>;\n\n  constructor(config: SimParams) {\n    this.ac = config.ac;\n    this.sm = config.sm;\n    this.pb = config.pb;\n    this.level = config.level;\n\n    this.varReg = new Map();\n    this.funcReg = new Map();\n    this.critStack = [];\n  }\n\n  crit() {\n    return !!this.critStack[this.critStack.length - 1];\n  }\n\n  popCrit() {\n    this.critStack.pop();\n  }\n\n  pushCrit(newCrit: boolean) {\n    this.critStack.push(newCrit);\n  }\n\n  reset() {\n    this.critStack.length = 0;\n    this.funcReg.clear();\n    this.varReg.clear();\n  }\n}\n\nexport default SimState;\n","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","import _typeof from \"./typeof.js\";\nimport assertThisInitialized from \"./assertThisInitialized.js\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return assertThisInitialized(self);\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nimport possibleConstructorReturn from \"./possibleConstructorReturn.js\";\nexport default function _createSuper(Derived) {\n  var hasNativeReflectConstruct = isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}","export default function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","import Expression from './expressions/Expression';\nimport SimState from './SimState';\n\nexport class BaseSimulation {\n  rawExpression: string;\n  rootExpression: Expression;\n\n  constructor(rawExpr: string, rootExpr: Expression) {\n    this.rawExpression = rawExpr\n    this.rootExpression = rootExpr\n  }\n\n  run(initialState: SimState) {\n    return this.rootExpression.eval(initialState)\n  }\n}\n\nexport default class Simulation extends BaseSimulation {\n  name: string;\n  level: number;\n  simDefinition: string;\n  error?: string;\n\n  constructor(name: string, level: number, simDef: string, rawExpr: string, rootExpr: Expression) {\n    super(rawExpr, rootExpr);\n    this.name = name;\n    this.level = level;\n    this.simDefinition = simDef;\n    this.error = undefined;\n  }\n  \n  id() {\n    return `${this.name}@${this.level}`;\n  }\n\n  isValid() {\n    return !this.error;\n  }\n}\n","import { parseSimExpr } from 'sim/parse';\nimport SimParams from 'sim/SimParams';\nimport SimState from 'sim/SimState';\nimport { BaseSimulation } from 'sim/Simulation';\nimport { MutableDistribution } from 'util/Distribution';\nimport { ToWorkerMessages } from './Messages';\n\n// Each worker will be effectively run in a separate interpreter, so global\n// state isn't actually very global; each worker will have their own copy of\n// the below state\nlet simulation: BaseSimulation | undefined;\nlet simParams: SimParams | undefined;\n\nonmessage = function(event: MessageEvent<ToWorkerMessages>) {\n  const { data } = event;\n  if (data.command === 'configure') {\n    const { expression, config } = data;\n    simulation = new BaseSimulation(expression, parseSimExpr(expression));\n    simParams = config;\n  } else if (data.command === 'run') {\n    const { iterations } = data;\n    const distribution = runSims(iterations);\n    this.postMessage({ command: 'complete', distribution });\n  }\n}\n\nfunction runSims(iterations: number) {\n  if (!simulation || !simParams) throw new Error('Worker is not configured!');\n  const results = new MutableDistribution();\n  const state = new SimState(simParams);\n  for (let i = 0; i < iterations; i++) {\n    state.reset();\n    results.increment(simulation.run(state));\n  }\n  return results.toImmutable();\n}\n\nexport {}\n","class Distribution {\n  protected map: Map<number, number>;\n  protected sumTotal: number;\n\n  constructor(entries?: [number, number][]) {\n    this.map = new Map(entries);\n    this.sumTotal = (entries || []).reduce((sum, [, count]) => sum + count, 0);\n  }\n\n  uniqueCount() {\n    return this.map.size;\n  }\n\n  totalCount() {\n    return this.sumTotal;\n  }\n\n  entries() {\n    return [...this.map.entries()];\n  }\n\n  uniqueValues() {\n    return [...this.map.keys()];\n  }\n\n  static merge(...dists: Distribution[]) {\n    const merged = new Distribution();\n    const m = merged.map;\n    dists.forEach((dist) => {\n      dist.map.forEach((c, v) => m.set(v, (m.get(v) || 0) + c));\n      merged.sumTotal += dist.sumTotal;\n    });\n    return merged;\n  }\n}\n\nexport class MutableDistribution extends Distribution {\n  increment(value: number) {\n    this.map.set(value, (this.map.get(value) || 0) + 1);\n    this.sumTotal += 1;\n  }\n\n  toImmutable() {\n    return new Distribution(this.entries());\n  }\n}\n\nexport default Distribution;\n"],"names":["_arrayLikeToArray","arr","len","length","i","arr2","Array","_unsupportedIterableToArray","o","minLen","n","Object","prototype","toString","call","slice","constructor","name","from","test","isArray","_i","Symbol","iterator","_s","_e","_arr","_n","_d","next","done","push","value","err","TypeError","_createForOfIteratorHelper","allowArrayLike","it","F","s","e","f","normalCompletion","didErr","step","_e2","_toConsumableArray","iter","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","Expression","typeName","expr","subExprs","evalFunc","rawExpression","subExpressions","this","state","ExpressionCreator","params","regex","parseFunc","min","max","sample","description","minSubExprs","maxSubExprs","Error","matches","exec","substring","randomFunction","Math","random","NoPF","NoMax","sum","values","reduce","prev","cur","roll","die","floor","expressionUtils","splitExpr","checkType","type_names","includes","SplitExpressions","m","exprs","storedType","ctx","funcName","funcReg","set","varName","varReg","eval","critmin","Number","vantage","num","droll","rolls","start","stop","undefined","result","range","abs","map","crit","ac","pushCrit","popCrit","successmod","dmg","sm","a","valueExpr","rollOperations","kh","param","sort","b","kl","rrle","ds","forEach","v","rrlt","rrge","rrgt","rreq","rollOpRegex","keys","join","ValueExpressions","RegExp","crittable","dieSize","numDice","operations","matchAll","om","operation","numWithCrit","pb","level","get","regexMatchAt","str","index","appendChunk","chunk","resets","startsWith","endsWith","opRegex","braces","currentChunk","chunkParensResets","curChar","opMatch","parseSimExpr","rawExpr","exprCreator","parts","parensGroups","create","SimState","config","critStack","Map","pop","newCrit","clear","_setPrototypeOf","p","setPrototypeOf","__proto__","_inherits","subClass","superClass","_getPrototypeOf","getPrototypeOf","_typeof","obj","_possibleConstructorReturn","self","ReferenceError","_createSuper","Derived","hasNativeReflectConstruct","Reflect","construct","sham","Proxy","Boolean","valueOf","Super","NewTarget","arguments","apply","simulation","simParams","BaseSimulation","rootExpr","rootExpression","initialState","Distribution","entries","sumTotal","size","merged","dists","dist","c","MutableDistribution","onmessage","event","data","command","expression","distribution","iterations","results","reset","increment","run","toImmutable","runSims","postMessage"],"sourceRoot":""}